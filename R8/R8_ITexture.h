#pragma once
#include "getvfunc.h"

class ITexture {
public:
	//DVMethod(int(), GetActualWidth, StaticVIndex<3>);
	int GetActualWidth()
	{
		typedef int (__thiscall* OriginalFn)(ITexture*);
		return getvfunc<OriginalFn>(this, 3)(this);
	}
	//DVMethod(int(), GetActualHeight, StaticVIndex<4>);
	int GetActualHeight()
	{
		typedef int(__thiscall* OriginalFn)(ITexture*);
		return getvfunc<OriginalFn>(this, 4)(this);
	}
};

#include "Materials.h"
class IMatRenderContext {
public:
	//DVMethod(int(), Release, StaticVIndex<1>);
	int Release()
	{
		typedef int(__thiscall* OriginalFn)(IMatRenderContext*);
		return getvfunc<OriginalFn>(this, 1)(this);
	}
	//DVMethod(void(ITexture* pTexture), SetRenderTarget, StaticVIndex<6>);
	void SetRenderTarget(ITexture* pTexture)
	{
		typedef void(__thiscall* OriginalFn)(ITexture*);
		return getvfunc<OriginalFn>(this, 6)(pTexture);
	}
	//DVMethod(void(), PushRenderTargetAndViewport, StaticVIndex<118>);
	void PushRenderTargetAndViewport()
	{
		typedef void(__thiscall* OriginalFn)(IMatRenderContext*);
		return getvfunc<OriginalFn>(this, 105)(this);
	}
	//DVMethod(void(), PopRenderTargetAndViewport, StaticVIndex<119>);
	int PopRenderTargetAndViewport()
	{
		typedef int(__thiscall* OriginalFn)(IMatRenderContext*);
		return getvfunc<OriginalFn>(this, 119)(this);
	}

	/*DVMethod(void(
		IMaterial* pMaterial,
		int destX, int destY, int width, int height,
		float srcTextureX0, float srcTextureY0, float srcTextureX1, float srcTextureY1,
		int srcTextureWidth, int srcTextureHeight,
		void* pClientRenderable, int nXDice, int nYDice
		), DrawScreenSpaceRectangle, StaticVIndex<113>);*/

	void DrawScreenSpaceRectangle(
		IMaterial* pMaterial,
		int destX, int destY, int width, int height,
		float srcTextureX0, float srcTextureY0, float srcTextureX1, float srcTextureY1,
		int srcTextureWidth, int srcTextureHeight,
		void* pClientRenderable, int nXDice, int nYDice
	)
	{
		typedef void(__thiscall* OriginalFn)(IMatRenderContext*, IMaterial*, int, int, int, int, float, float ,float, float, int, int, void*, int, int);
		return getvfunc<OriginalFn>(this, 103)(this,
			pMaterial, destX, destY, width, height,
			srcTextureX0, srcTextureY0, srcTextureX1, srcTextureY1,
			srcTextureWidth, srcTextureHeight,
			pClientRenderable, nXDice, nYDice);
	}
};

#define CREATERENDERTARGETFLAGS_HDR				0x00000001
#define CREATERENDERTARGETFLAGS_AUTOMIPMAP		0x00000002
#define CREATERENDERTARGETFLAGS_UNFILTERABLE_OK 0x00000004

// NOTE: All size modes will force the render target to be smaller than or equal to
// the size of the framebuffer.
enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0, // Only allowed for render targets that don't want a depth buffer
	// (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
	RT_SIZE_DEFAULT = 1,				// Don't play with the specified width and height other than making sure it fits in the framebuffer.
	RT_SIZE_PICMIP = 2,				// Apply picmip to the render target's width and height.
	RT_SIZE_HDR = 3,					// frame_buffer_width / 4
	RT_SIZE_FULL_FRAME_BUFFER = 4,	// Same size as frame buffer, or next lower power of 2 if we can't do that.
	RT_SIZE_OFFSCREEN = 5,			// Target of specified size, don't mess with dimensions
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6, // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
	RT_SIZE_REPLAY_SCREENSHOT = 7,	// Rounded down to power of 2, essentially...
	RT_SIZE_LITERAL = 8				// Use the size passed in. Don't clamp it to the frame buffer size. Really.
};

//-----------------------------------------------------------------------------
// Flags to specify type of depth buffer used with RT
//-----------------------------------------------------------------------------

// GR - this is to add RT with no depth buffer bound

enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};

//-----------------------------------------------------------------------------
// Texture flags
//-----------------------------------------------------------------------------
enum CompiledVtfFlags
{
	// flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_SRGB = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_UNUSED_00080000 = 0x00080000,
	TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
	TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
	TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,

	TEXTUREFLAGS_CLAMPU = 0x02000000,

	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,					// Useable as a vertex texture

	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,

	// Clamp to border color on all texture coordinates
	TEXTUREFLAGS_BORDER = 0x20000000,

	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
};

class IMaterialSystem {
public:
	//DVMethod(ImageFormat(), GetBackBufferFormat, StaticVIndex<36>);
	ImageFormat GetBackBufferFormat()
	{
		typedef ImageFormat(__thiscall* OriginalFn)();
		return getvfunc<OriginalFn>(this, 32)();
	}
	//DVMethod(void(), BeginRenderTargetAllocation, StaticVIndex<94>);
	void BeginRenderTargetAllocation()
	{
		typedef void(__thiscall* OriginalFn)(IMaterialSystem*);
		return getvfunc<OriginalFn>(this, 84)(this);
	}
	//DVMethod(void(), EndRenderTargetAllocation, StaticVIndex<95>);
	void EndRenderTargetAllocation()
	{
		typedef void(__thiscall* OriginalFn)(IMaterialSystem*);
		return getvfunc<OriginalFn>(this, 86)(this);
	}
	//DVMethod(IMatRenderContext*(), GetRenderContext, StaticVIndex<115>);
	IMatRenderContext* GetRenderContext()
	{
		typedef IMatRenderContext*(__thiscall* OriginalFn)(IMaterialSystem*);
		return getvfunc<OriginalFn>(this, 100)(this);
	}

	/*DVMethod(ITexture*(
		const char* name, int w, int h, RenderTargetSizeMode_t sizeMode,
		ImageFormat format, MaterialRenderTargetDepth_t depth,
		TextureFlags textureFlags, CreateRenderTargetFlags renderTargetFlags
		), CreateNamedRenderTargetTextureEx, StaticVIndex<97>);*/



	//DVar(bool, m_bGameStarted, PatternOffset<modules::materialsystem, patterns::CMaterialSystem_m_bGameStarted>);
	bool* m_bGameStarted = nullptr;

	void forceBeginRenderTargetAllocation()
	{
		//bool oldState = *m_bGameStarted;
		//*m_bGameStarted = false; // Fooling the game that loading is not finished yet
		BeginRenderTargetAllocation();
		//*m_bGameStarted = oldState;
	}

	void forceEndRenderTargetAllocation()
	{
		//bool oldState = *m_bGameStarted;
		//*m_bGameStarted = false;
		EndRenderTargetAllocation();
		//*m_bGameStarted = oldState;
	}

	// 87	CMaterialSystem::CreateNamedRenderTargetTextureEx(char const*,int,int,RenderTargetSizeMode_t,ImageFormat,MaterialRenderTargetDepth_t,unsigned int,unsigned int)
	ITexture* CreateNamedRenderTargetTextureEx(const char *pRTName, // Pass in NULL here for an unnamed render target.
		int w,
		int h,
		RenderTargetSizeMode_t sizeMode,	// Controls how size is generated (and regenerated on video mode change).
		ImageFormat format,
		MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED,
		unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT,
		unsigned int renderTargetFlags = 0)
	{
		typedef ITexture*(__thiscall* OriginalFn)(IMaterialSystem*, const char*, int, int, RenderTargetSizeMode_t, ImageFormat, MaterialRenderTargetDepth_t, unsigned, unsigned);
		return getvfunc<OriginalFn>(this, 87)(this, pRTName, w, h, sizeMode, format, depth, textureFlags, renderTargetFlags);
	}

	ITexture* createFullFrameRenderTarget(const char* name) {
		return CreateNamedRenderTargetTextureEx(
			name, 1, 1, RT_SIZE_FULL_FRAME_BUFFER, GetBackBufferFormat(),
			MATERIAL_RT_DEPTH_SHARED, TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT,
			CREATERENDERTARGETFLAGS_HDR
		);
	}
};

#include "Base.h"
typedef Vector Vec3;
typedef Vector QAngle;

class CViewSetup {
public:
	int x;
	int oldX;
	int y;
	int oldY;
	int width;
	int oldWidth;
	int height;
	int oldHeight;

	bool m_bOrtho;
	float m_OrthoLeft;
	float m_OrthoTop;
	float m_OrthoRight;
	float m_OrthoBottom;

private:
	char pad1[0x7C];

public:
	float fov;
	float fovViewmodel;
	Vec3 origin;
	QAngle angles;

	float zNear;
	float zFar;
	float zNearViewmodel;
	float zFarViewmodel;

	float m_flAspectRatio;
	float m_flNearBlurDepth;
	float m_flNearFocusDepth;
	float m_flFarFocusDepth;
	float m_flFarBlurDepth;
	float m_flNearBlurRadius;
	float m_flFarBlurRadius;
	int m_nDoFQuality;
	/*MotionBlurMode_t*/ int m_nMotionBlurMode;

	float m_flShutterTime;
	Vec3 m_vShutterOpenPosition;
	QAngle m_shutterOpenAngles;
	Vec3 m_vShutterClosePosition;
	QAngle m_shutterCloseAngles;

	float m_flOffCenterTop;
	float m_flOffCenterBottom;
	float m_flOffCenterLeft;
	float m_flOffCenterRight;

	bool m_bOffCenter : 1;
	bool m_bRenderToSubrectOfLargerScreen : 1;
	bool m_bDoBloomAndToneMapping : 1;
	bool m_bDoDepthOfField : 1;
	bool m_bHDRTarget : 1;
	bool m_bDrawWorldNormal : 1;
	bool m_bCullFrontFaces : 1;
	bool m_bCacheFullSceneState : 1;
	bool m_bRenderFlashlightDepthTranslucents : 1;
private:
	char pad2[0x40];
};